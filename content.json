{"meta":{"title":"ChenC","subtitle":"Rendering","description":"Learning graphics as a pawn","author":"chenc","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"unreal中的捏脸系统","slug":"unreal中的捏脸系统","date":"2019-09-30T10:19:45.000Z","updated":"2019-10-01T13:47:21.091Z","comments":true,"path":"2019/09/30/unreal中的捏脸系统/","link":"","permalink":"http://yoursite.com/2019/09/30/unreal中的捏脸系统/","excerpt":"","text":"《楚留香》《逆水寒》《天涯明月刀》等一批武侠游戏都将捏脸系统作为了标配，并且开放了大量的参数给玩家，从而能够自由的发挥自己的想象力，捏出一堆鬼脸~在知乎（《Honey Select》）以及其他文章里对捏脸的原理进行了详细的分析，本文呢，主要记录基于骨骼的捏脸在Unreal4中的实现。 原理基于调整骨骼进行捏脸的核心就是修改脸部骨骼的Scale、Rotation，Position，从而改变骨骼对应的蒙皮的顶点的位置，以达到捏脸的效果， 上图是在动画蓝图里添加一个内置的改变骨骼的节点（下图）来修改鼻子的x坐标的scale 的效果： 看起来捏脸也就这么回事了！但是呢，要想达到游戏中千人千面的效果，基于骨骼的捏脸有以下几点要求： 需要设计一套有足够表达能力的骨骼以及细致的脸部蒙皮； 大量的骨骼对应的大量参数带来的自由度过高，不易调节，应便于用户调节； 性能消耗相对较少； 跟现有的动画系统以及基于blendshape的表情兼容； 如果有AI能力，根据用户提供的照片自动生成对应的模型是最好不过的了； 有一套对应的妆容方案； 其中 1 主要由3D建模师操作，另外对于脸部的对称部分，设计其对应的骨骼为对称骨骼，从而方便调节；对于第二条，大部分的游戏会设计一套叫做controller的第二层骨骼，每个controller同时操纵多根骨骼的多个参数的不同组合来调节局部区域，controller1控制眼部的整体的大小，需要添加眼部骨骼到controller控制的骨骼的列表中，controller的示意图如下:这样用户通过操纵controller的滑竿便可以一次性调节一个局部区域，实际上，通过二层骨骼我们降低了局部骨骼参数的自由度，从而方便用户精细的调整角色脸部的细节表情。举例：controller1通过控制三根骨骼的缩放参数来达到整体调节眼部大小的目的：3暂且按下不表；接下来4的话会涉及到如何在unreal里实现捏脸，因此会展开详细记录。 Unreal实现首先，开篇所述的直接用ModifyBone蓝图节点来修改每根骨骼的话，对于程序非常的不友好，为了捏脸的效果和充分的表达能力，SkeletalMesh中通常设置较多的骨骼，因此直接使用ModifyBone节点是不太方便的。我们整体的逻辑应该是这样： 根据json文件解析出的controller生成所有的调节滑杆，并加载其默认值； 如果滑杆值发生变化，则对应线性插值或者样条插值该controller对应的所有的骨骼的对应的参数； 然后将变化的相对Transform更新到骨架的transform上； Rendering。第一步和第二步实现比较简单，略去。对于第三步在Unreal中针对骨架有多套数据结构，从捏脸的方便性上来说，这里我们选择PoseableMesh来操作，查看PoseableMeshComponent.h的源码，可以看到以下函数： class ENGINE_API UPoseableMeshComponent : public USkinnedMeshComponent { GENERATED_UCLASS_BODY() /** Temporary array of local-space (ie relative to parent bone) rotation/translation/scale for each bone. */ TArray BoneSpaceTransforms; UFUNCTION(BlueprintCallable, Category=”Components|PoseableMesh”) void SetBoneTransformByName(FName BoneName, const FTransform&amp; InTransform, EBoneSpaces::Type BoneSpace); UFUNCTION(BlueprintCallable, Category=”Components|PoseableMesh”) FTransform GetBoneTransformByName(FName BoneName, EBoneSpaces::Type BoneSpace); UFUNCTION(BlueprintCallable, Category=”Components|PoseableMesh”) void ResetBoneTransformByName(FName BoneName); UFUNCTION(BlueprintCallable, Category=”Components|PoseableMesh”) void CopyPoseFromSkeletalComponent(const USkeletalMeshComponent* InComponentToCopy); };可以看到利用PoseableMesh我们可以方便的操纵Transform，从而达到捏脸的目的。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-09-30T10:08:14.195Z","updated":"2019-09-30T10:08:14.196Z","comments":true,"path":"2019/09/30/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}